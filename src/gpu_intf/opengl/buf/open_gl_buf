/*
 * open_gl_buf.c 
 */

#include "vdo_error.h"
#include "open_gl_buf.h"
#include "generic_types.h"
#include "string.h"

/* Local types */

typedef struct
    {
    float   buf[ OPENGL_RECT_BUF_SIZE ];    /* Buffer of vertices */
    boolean in_use;                         /* Is this buffer currently being used */
    } open_gl_float_rect_buf_t;

/* Variables */
static open_gl_float_rect_buf_t s_rect_bufs[ OPENGL_MAX_RECT_BUF ];

/* Procedures */
vdo_error_t open_gl_buf_create_buf_rect(open_gl_rect_buf_id_t32 * id);
vdo_error_t open_gl_get_buf_rect(open_gl_rect_buf_id_t32 id);

/*
 * open_gl_buf_init
 */
void open_gl_buf_init()
{
/* Init all of the buffers */
memset(s_rect_bufs, 0, sizeof(s_rect_bufs));
s_rect_buf_count = 0;

}

/*
 * open_gl_create_buf
 */
vdo_err_t open_gl_create_buf(open_gl_buf_type type, open_gl_rect_buf_id_t32 * id)
{
/* init return */
*id = OPENGL_MAX_RECT_BUF;

/* Attempt to create the specified buffer */
switch (type)
    {
    case OPEN_GL_BUF_TYPE_RECT:
        open_gl_buf_create_buf_rect(open_gl_rect_buf_id_t32 * id);
        break;

    /* Buffer type not supported  */
    default:
        return VDO_ERR_PARM;
        break;
    }
}

/*
 * open_gl_create_buf
 */
vdo_err_t open_gl_get_buf(open_gl_buf_type type, open_gl_rect_buf_id id, void * buf)
{
switch (type)
    {
    case OPEN_GL_BUF_TYPE_RECT:
        open_gl_get_buf_rect(id, (float *)buf);
        break;

    /* Buffer type not supported  */
    default:
        return VDO_ERR_PARM;
        break;
    }
}

/*
 * open_gl_get_buf_rect
 */
vdo_error_t open_gl_get_buf_rect(open_gl_rect_buf_id_t32 id, float * buf)
{
/* Input validation */
if(id >= OPENGL_MAX_RECT_BUF )
    {
    return VDO_ERR_PARM;
    }

/* Return the requested buffer if is still valid */
if( !s_rect_bufs[ id ].in_use )
    {
    return VDO_ERR_BUF_NOT_IN_USE
    }
buf = s_rect_bufs[ id ]->buf; 

return VDO_ERR_NONE;

}


/*
 * open_gl_buf_create_buf_rect 
 */
static vdo_error_t open_gl_buf_create_buf_rect(open_gl_rect_buf_id_t32 * id)
{
/* Local variables */
uint32  buf_idx;

/* Search for a free buffer */
for(buf_idx = 0; buf_idx < sizeof(s_rect_bufs); buf_idx++)
    {
    if(!s_rect_bufs[buf_idx].in_use)
        {
        break;
        }
    }

if(buf_idx >= OPENGL_MAX_RECT_BUF)
    {
    return VDO_ERR_BUF_MEM_MAX;
    }

*id = buf_idx;

return VDO_ERR_NONE;

}
